=============================
GREETING
=============================
Καλησπέρα, είμαι ο Ορέστης Μελκονιάν και θα σας μιλήσω για ενα framework που άρχισα να αναπτύσσω στα πλαισία της πρακτικής μου στο Δημόκριτο. Θα σας μιλήσω αρχικά λίγο γενικά για τον προγραμματισμό ρομποτικών εφαρμογών. Έπειτα θα σας πω συνοπτικά τις δυνατότητες που προσφέρει το framework και τέλος τι σκοπεύω να κάνω τους επόμενους μήνες.

=============================
ROBOT PROGRAMMING
=============================
	RPA
	===
	Οι περισσοτερες ρομποτικες εφαρμογες ακολουθουν τη λεγομενη Robot Perception Architecture (RPA), στην οποία το σύστημα έχει ως είσοδο του αισθητήρες του robot με τις οποίες αντιλαμβανεται το περιβαλλον του (πχ καμερα), οι οποίοι οδηγούνται σε καποιους εσωτερικους κομβους υπολογισμου οι οποιο μεταφερουν το αποτελεσμα τους ειτε σε επομενους κομβους ειτε ως εντολες στους αctuators, με τους οποίους το robot επεμβαίνει στο περιβάλλον του.

	Feedback
	========
	Κάτι που εμφανίζεται συνέχεια στη θεωρία ελέγχου και αυτοματισμού ειναι οι feedback loop controllers οπου η εξοδος των κομβων υπολογισμού ξαναεισερχεται ως εισοδος στο σύστημα. (πχ PID controller)

	Εύκολα φαίνεται ότι τέτοια συστήματα θα μπορούσαν να περιγραφούν πολύ φυσικά και διαισθητικά με το dataflow μοντέλο, και όντως στη βιβλιογραφία εμφανίζονται συνέχεια dataflow διαγραμμάτα.

	ROS
	===
	Ενα απο τα μεγαλυτερα θεματα που παρουσιαζονται ειναι αυτο του reusability. Καθε ρομποτ εχει και διαφορετικο driver οποτε ειναι αρκετο δυσκολο και χρονοβορο να προγραμματισεις μια γενικη ρομποτικη εφαρμογη, η να προσαρμοσεις μια υπαρχουσα. 

	Γι αυτο το λογο εχουν βγει διαφορα middleware που προσφερουν αφαιρεση ως προς το hardware. Μια πολυ δημοφιλης open-source λυση ειναι το ROS που εχει μαζεψει ενα αρκετα μεγαλο community, ειδικα στον ερευνητικο χωρο, και εχει μαζεψει παρα πολλα πακετα λογισμικου ωστε να μεγιστοποιησει την επαναχρησιμοποιηση κωδικα. Ακολουθει το publish-subscribe design pattern. O χρήστης φτιάχνει διάφορα ROS nodes και η επικοινωνια μεταξύ τους γινεται μεσω των "topics" που ειναι απλα named fifo queues δεσμευμενα σε ενα τυπο μηνυματος. Δεν δεσμέυεται σε μία γλώσσα προγραμματισμού αν και τα περισσοτερα πακετα ειναι γραμμενα σε C++ η python. 

	Το κυριότερο προβλημα ειναι οτι ο χειρισμος των topics γινεται με ασυγχρονα callbacks, και στις περισσοτερες περιπτωσεις που ειναι απαραιτητος ο συνδυασμος/συγχονισμος διαφορων topics αυτη η σχεδιαση δεν ειναι η καταλληλη μιας και για να το πετύχουμε αυτό πρέπει να κάνουμε βρώμικο εσωτερικό "plumbing".

	Επίσης, η αρχιτεκτονική του ROS μπορεί κι αυτή να αναπαρασταθεί ως dataflow, με κόμβους τα ROS nodes και ακμές τα topics.

	Άρα, μήπως θα έπρεπε να υπάρχει μια dataflow γλώσσα μέσα στο ROS, αφενός για τον ορισμό των επιμέρους nodes σύμφωνα με την RP αρχιτεκτονική και αφετέρου για τον συντονισμό πολλών ROS nodes με αυθαίρετο τρόπο?
=============================
STREAM FRAMEWORK
=============================
Αυτή είναι η κυρια ιδεα της ongoing δουλειας μου, δηλαδή να αντικαταστησω τον μηχανισμο των callbacks, μετατρέποντας τα topics σε streams και πραγματοποιώντας τον χειρισμό τους με συναρτησιακούς τελεστές, ουσιαστικά οριζοντας ενα dataflow γράφο.	

Προσφέρεται ένα πλούσιο σετ τελεστών, ώστε να μπορεί να οριστεί οποισδήποτε dataflow γράφος, ακόμα και με κύκλους (τελεστής loop).

Στο επιπεδο του ορισμού των nodes, θα λυθεί το προβλημα του "internal plumbing" που δημιουργουν τα callbacks και οδηγεί σε βρώμικο, μη-συντηρησιμο κώδικα, έχοντας πιο κατάλληλους μηχανισμούς διαχείρισης των topics(map, filter, merge, zip...) που οδηγούν σε πιο αφαιρετικό και τελικά πιο ομορφο κωδικα. 

Πηγαίνοντας ένα επίπεδο αφαιρεσης παραπάνω, ο ros coder μπορεί να μη σκέφτεται καν ROS nodes και απλά να ορίζει (δηλωτικά) ενα dataflow γράφο, το οποίο θα εκτελεστεί από το επιλεγμένο EvaluationStrategy. Δεν ήθελα να δεσμευτώ με ένα συγκεκριμένο μοντέλο εκτέλεσης (πχ data/demand-driven), οπότε ακολούθησα το Strategy design pattern για να μπορεί να επεκταθεί εύκολα το framework.

Μπορούμε να διαχωρίσουμε τα EvaluationStrategies σε 2 τάξεις. Αυτά της 0-τάξης απλά εκτελούν το dataflow γράφο σε ένα μηχανήμα (πχ με java.util.streams, rxjava h akka) ίσως με πολλά threads. Αυτά της 1-τάξης αφορούν ένα δίκτυο μηχανημάτων και μοιράζουν το γράφο κατάλληλα ανάμεσα τους εφαρμόζοντας μια στρατηγική 0-τάξης στην κάθεμια. Εως τώρα έχω υλοποιήσει μια στρατηγική 0-τάξης με rxjava και μια στρατηγική 1-τάξης με ROS nodes, δηλαδή κάθε stream operator εκτελείται σε διαφορετικό ROS node και η πληροφορία ρέει μέσα από τα ROS topics.

Αυτος ο τροπος προγραμματισμού προσφέρει μια πιο υψηλού επιπέδου οπτική στον προγραμματιστή, αποκρύπτωντας το πως θα εκτελεστεί το dataflow που έχουν ορίσει. 

Επίσης, δεν χρειάζεται να ασχοληθεί με threads/processes για να επιτύχει παραλληλία αφού τέτοιες ευκαιρίες αναδύονται μόνο και μόνο απο τον ορισμό του dataflow. 

Ένα άλλο πολύ χρήσιμο feature είναι η αυτόματη διαχείριση της ανταλλαγής μηνυμάτων ανάμεσα στους κόμβους του γράφου, δηλαδή ο χρήστης δεν χρειάζεται να ασχοληθεί με το setup των μηνυμάτων και τον ορισμό των topics.

=============================
FUTURE WORK
=============================
Στους επόμενους 3 μήνες έχω σκοπό να δώσω έμφαση σε 3 πράγματα. 

Extensions
============
1ov, θέλω να προσθέσω κάποια πολύ χρήσιμα features, όπως να ορίζεις δικού σου operators ή να βάζεις ήδη υπάρχοντα ROS nodes μέσα στο γράφο, ουσιαστικά χρησιμοποιώντας το framework ως ένα μηχανισμό συντονισμού διαφορετικών components. Βέβαια αυτό έχει ως συνέπεια τον περιορισμό του granularity του γράφου, εκτός βέβαια και αν είναι ROS node γραμμένο με streams, οπότε απλά εισέρχεται ως υπογράφος, περιέχοντας όλες τις εσωτερικές λεπτομέρειες.

Οptimization
============
2ον, είναι απαραίτητο να υπάρχει κάποιο γενικό optimization ανεξάρτητα από την εκάστοτε στρατηγική διατηρόντας φυσικά τα semantics (πχ μετακίνηση των filter όσο πιο νωρίς γίνεται). 

Στο επίπεδο του distribution (δηλαδή στις στρατηγικές 1ης τάξης) θα ήταν πολύ χρήσιμο να προσαρμόζεται το granularity του γράφου ανάλογα με αυτό του δίκτυου, μέσω fusion, δηλαδή ένα ROS node να εκτελεί ένα μη-τετριμμένο μέρος του γράφου, αντί για μόνο έναν τελεστή.

DSL
============
3ον, σκοπεύω να τυλίξω όλη αυτή τη λειτουργικότητα με μια DSL, ώστε ο συμβολισμός να είναι πιο σύντομος και ίσως εμπλουτιστεί με ειδικές σημειώσεις πχ για τις ιδιότητες των operators (όπως stateless, selectivity, κλπ).

Τώρα είναι απλά μια βιβλιοθήκη java, οπότε αφήνει το χρήστη να κάνει πράγματα που δεν έχουν νόημα, όπως reassign μια μεταβλητή τύπου Stream ή shared variables σε τμήματα κώδικα που εκτελείται από πολλά threads. Η DSL θα απαγορεύει ανούσιες ενέργειες του χρήστη.

Ένα ακόμα πράγμα που παρατηρούμε, έιναι ότι όλα τα προγράμματα έχουν μια συγκεκριμένη δομή (ορισμός των topics, ορισμός της στρατηγικής εκτέλεσης, ορισμός του γράφου), οπότε μπορούμε να ελαχιστοποιήσουμε τα προβλήματα σχεδίασης επιβάλλοντας στο χρήστη αυτή τη δομή.

=============================
CONCLUSION
=============================
Τελειώνοντας, να αναφέρω ότι η δουλειά αυτή είναι μέρος μιας γενικότερης συνεχής προσπάθειας να δημιουργούμε όλο και πιο αφαιρετικά εργαλεία και γλώσσες όσω τα προβλήματα που εμφανίζονται γίνονται όλο και πιο πολύπλοκα. Ένα τέτοιο παράδειγμα είναι η γλώσσα Ziria, που μας παρουσίασε πέρσυ ο κ.Βυτινιώτης, που το επιτυχαίνει αυτό στο πεδίο του προγραμματισμού wireless συστημάτων. 


	

