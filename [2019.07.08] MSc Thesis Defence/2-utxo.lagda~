\section{UTxO}
\subsection{Transactions/Ledgers}
\begin{frame}{Basic Types}
\begin{agda}\begin{code}
module UTxO.Types (Value : Set) (Hash : Set) where DOTS

record State : Set where
  field  height : ‚Ñï
         VDOTS

record HashFunction (A : Set) : Set where
  field  hashF      : A ‚Üí Hash
         injective  : ‚àÄ {x y} ‚Üí x ‚ôØ ‚â° y ‚ôØ ‚Üí x ‚â° y

postulate
  UL ‚ôØ : ‚àÄ {A : Set} ‚Üí HashFunction A
\end{code}\end{agda}
\end{frame}

\begin{frame}{Inputs and Output References}
\begin{agda}\begin{code}
record TxOutputRef : Set where
  constructor _ at _
  field  id     : Hash
         index  : ‚Ñï

record TxInput : Set where
  field  outputRef  : TxOutputRef
##
         R  D       : ùïå
         redeemer   : State ‚Üí el R
         validator  : State ‚Üí Value ‚Üí PendingTx ‚Üí el R ‚Üí el D ‚Üí Bool
\end{code}\end{agda}

\begin{itemize}
\item |ùïå| is a simple type universe for first-order data.
\end{itemize}

\end{frame}

\begin{frame}{Transactions}
\begin{agda}\begin{code}
module UTxO  (Address : Set)
             (_ ‚ôØ ^^ SUBA : Hash Address)
             (_ ‚âü SUBA _ : Decidable {A = Address} _ ‚â° _) where
##
record TxOutput : Set where
  field  value       : Value
         address     : Address
##
         Data        : ùïå
         dataScript  : State ‚Üí el Data

record Tx : Set where
  field  inputs   : Set‚ü® TxInput ‚ü©
         outputs  : List TxOutput
         forge    : Value
         fee      : Value

Ledger : Set
Ledger = List Tx
\end{code}\end{agda}
\end{frame}

\begin{frame}{Validation}
\begin{agda}\begin{code}
runValidation  :  PendingTx
               ‚Üí  (i : TxInput)
               ‚Üí  (o : TxOutput)
               ‚Üí  D i ‚â° Data o
               ‚Üí  State
               ‚Üí  Bool
runValidation ptx i o refl st = validator i st (value o) ptx (redeemer i st) (dataScript o st)
\end{code}\end{agda}
\end{frame}

\begin{frame}{Unspent Outputs}
\begin{agda}\begin{code}
unspentOutputs : Ledger ‚Üí Set‚ü® TxOutputRef ‚ü©
unspentOutputs []           = ‚àÖ
unspentOutputs (tx ‚à∑ txs)  = (unspentOutputs txs ‚îÄ spentOutputsTx tx) ‚à™ unspentOutputsTx tx
  where
    spentOutputsTx, unspentOutputsTx : Tx ‚Üí Set‚ü® TxOutputRef ‚ü©
    spentOutputsTx       = (outputRef ‚ü®$‚ü© UR) ‚àò inputs
    unspentOutputsTx tx  = (tx ‚ôØ ^^ at UR) ‚ü®$‚ü© indices (outputs tx)
\end{code}\end{agda}
\end{frame}

\subsection{Validity}
\begin{frame}{Validity I}
\savecolumns
\begin{agda}\begin{code}
record IsValidTx (tx : Tx) (l : Ledger) : Set where
field
  validTxRefs : ‚àÄ i ‚Üí i ‚àà inputs tx ->
    Any (Œª t ‚Üí t ‚ôØ ‚â° id (outputRef i)) l

  validOutputIndices : ‚àÄ i ‚Üí (iin : i ‚àà inputs tx) ->
    index (outputRef i) <
      length (outputs (lookupTx l (outputRef i) (validTxRefs i iin)))

  validOutputRefs : ‚àÄ i ‚Üí i ‚àà inputs tx ->
    outputRef i ‚àà unspentOutputs l

  validDataScriptTypes : ‚àÄ i ‚Üí (iin : i ‚àà inputs tx) ->
    D i ‚â° D (lookupOutput l (outputRef i) (validTxRefs i iin) (validOutputIndices i iin))
\end{code}\end{agda}
\end{frame}

\begin{frame}{Validity II}
\restorecolumns
\begin{agda}\begin{code}
  preservesValues :
    forge tx + sum (mapWith‚àà (inputs tx) Œª {i} iin ->
                     lookupValue l i (validTxRefs i iin) (validOutputIndices i iin))
      ‚â°
    fee tx + sum (value ‚ü®$‚ü© outputs tx)

  noDoubleSpending :
    noDuplicates (outputRef ‚ü®$‚ü© inputs tx)

  allInputsValidate : ‚àÄ i ‚Üí (iin : i ‚àà inputs tx) ->
    let  out = lookupOutput l (outputRef i) (validTxRefs i iin) (validOutputIndices i iin)
         ptx = mkPendingTx l tx validTxRefs validOutputIndices
    in   T (runValidation ptx i out (validDataScriptTypes i iin) (getState l))

  validateValidHashes : ‚àÄ i ‚Üí (iin : i ‚àà inputs tx) ->
    let  out = lookupOutput l (outputRef i) (validTxRefs i iin) (validOutputIndices i iin)
    in   (address out) ‚ôØ ‚â° validator i ‚ôØ
\end{code}\end{agda}
\end{frame}

\begin{frame}{Valid Ledgers}
\begin{agda}\begin{code}
data ValidLedger : Ledger ‚Üí Set where

  ‚àô           :  ValidLedger []

  _ ‚äï _ ‚à∂- _  :  ValidLedger l
              ‚Üí  (tx : Tx)
              ‚Üí  IsValidTx tx l
              ‚Üí  ValidLedger (tx ‚à∑ l)
\end{code}\end{agda}
\end{frame}

\begin{frame}{Decision Procedures}
\begin{agda}\begin{code}
VDOTS
validOutputRefs? : ‚àÄ (tx : Tx) (l : Ledger)
  ‚Üí Dec (‚àÄ i ‚Üí i ‚àà inputs tx ‚Üí outputRef i ‚àà unspentOutputs l)
validOutputRefs? tx l = ‚àÄ? (inputs tx) Œª i _ ‚Üí outputRef i ‚àà? unspentOutputs l
VDOTS
where
  ‚àÄ?  :  (xs : List A)
      ‚Üí  {P : (x : A) (xin : x ‚àà xs) ‚Üí Set}
      ‚Üí  (‚àÄ x ‚Üí (xin : x ‚àà xs) ‚Üí Dec (P x xin))
      ‚Üí  Dec (‚àÄ x xin ‚Üí P x xin)
\end{code}\end{agda}
\end{frame}


\subsection{Extensions}

\begin{frame}{Extension: Multi-currency}
\begin{enumerate}
\item Generalize values from integers to maps: |Value = List (Hash √ó ‚Ñï)|
\item Implement additive group operators (on top of AVL trees):
\begin{agda}\begin{code}
open import Data.AVL ‚Ñï-strictTotalOrder

CurrencyMap = Tree (MkValue (Œª _ ‚Üí Hash) (subst (Œª _ ‚Üí ‚Ñï)))

_ + SC _ : Value ‚Üí Value ‚Üí Value
c + SC c‚Ä≤ = toList (foldl go (fromList c) c‚Ä≤)
  where
    go : CurrencyMap ‚Üí (‚Ñï √ó ‚Ñï) ‚Üí CurrencyMap
    go cur (currency , value) = insertWith currency ((UL + value) ‚àò fromMaybe 0) cur

sum SC : List Value ‚Üí Value
sum SC = foldl UL + SC UR []
\end{code}\end{agda}
\end{enumerate}
\end{frame}

\begin{frame}{Multi-currency: Forging condition}
\begin{agda}\begin{code}
record IsValidTx (tx : Tx) (l : Ledger) : Set where
  DOTS
  forging :
    ‚àÄ c ‚Üí c ‚àà keys (forge tx) ‚Üí
      ‚àÉ[ i ] ^^ ‚àÉ Œª (iin : i ‚àà inputs tx) ‚Üí
        let out = lookupOutput l (outputRef i) (validTxRefs i iin) (validOutputIndices i iin)
        in (address out) ‚ôØ ‚â° c
\end{code}\end{agda}
\end{frame}


\subsection{Example}
\newcommand\forge[1]{forge: \bitcoin ~#1}
\newcommand\fee[1]{fee:\hspace{7pt} \bitcoin ~#1}
\begin{frame}{Example: Transaction Graph}
\begin{figure}\begin{tikzpicture}
  [basic box/.style = {
     draw,
     shape = rectangle,
     align = left,
     minimum width=2cm,
     minimum height=1.2cm,
     rounded corners},
   upedge/.style = {
     },
   downedge/.style = {
     },
   to/.style = {
     ->,
     >=stealth',
     semithick
  },
  every matrix/.style={column sep=1.3cm, row sep=1cm, ampersand replacement=\&},
  font=\footnotesize
  ]
  \matrix{
    \node[basic box, label = |t‚ÇÅ|] (t)
      {\forge{1000}\\ \fee{0}};
    \& \node[basic box, label = |t‚ÇÇ|] (tt)
      {\forge{0}\\ \fee{0}};
    \& \node[basic box, label = |t‚ÇÖ|] (tfive)
      {\forge{0}\\ \fee{7}};
    \& \node[basic box, label = |t‚ÇÜ|] (tsix)
      {\forge{0}\\ \fee{1}};
    \& \node (end) {}; \\

    \node[basic box, label = |c‚ÇÄ|] (c)
      {\forge{0}\\ \fee{0}};
    \& \node[basic box, label = |t‚ÇÉ|] (ttt)
      {\forge{0}\\ \fee{1}};
    \& \node {};
    \& \node {}; \\

    \node {};
    \& \node[basic box, label = |t‚ÇÑ|] (tfour)
      {\forge{10}\\ \fee{2}};
    \& \node {};
    \& \node {}; \\
  };

  \path
  (t) edge[to]
    node[above]{\bitcoin ~1000}
    node[below]{@@|ONEB|}
  (tt)
  (tt) edge[to, bend right = 30]
    node[left]{\bitcoin ~200}
    node[right]{@@|ONEB|}
  (ttt)
  (tt) edge[to]
    node[above]{\bitcoin ~800}
    node[below]{@@|TWOB|}
  (tfive)
  (ttt) edge[to, bend right = 30]
    node[left]{\bitcoin ~199}
    node[right]{@@|THREEB|}
  (tfour)
  (tfour) edge[to, bend right = 45]
    node[left]{\bitcoin ~207}
    node[right]{@@|TWOB|}
  (tfive)
  (tfive) edge[to, transform canvas={yshift=13pt}]
    node[above]{\bitcoin ~500}
    node[below]{@@|TWOB|}
  (tsix)
  (tfive) edge[to, transform canvas={yshift=-13pt}]
    node[above]{\bitcoin ~500}
    node[below]{@@|THREEB|}
  (tsix)
  (tsix) edge[to, red]
    node[above,black]{\bitcoin ~999}
    node[below,black]{@@|THREEB|}
  (end)
  (c) edge[to, bend left = 30, green]
    node[left,black]{\bitcoin-policy}
    node[right,black]{@@|BIT|}
  (t)
  (c) edge[to, bend right = 40, green]
    node[left,black]{\bitcoin-policy}
    node[right,black]{@@|BIT|}
  (tfour)
  ;
\end{tikzpicture}\end{figure}
\end{frame}

\begin{frame}{Example: Setting Up}
\begin{agda}\begin{code}
Address = ‚Ñï
##
ONEB , TWOB , THREEB : Address
ONEB    = 1 -- first address
TWOB    = 2 -- second address
THREEB  = 3 -- third address
##
open import UTxO Address (Œª x ‚Üí x) UL ‚âü UR
##
BIT -validator : State ‚Üí DOTS ‚Üí Bool
BIT -validator (record {height = h}) DOTS = (h ‚â° SB 1) ‚à® (h ‚â° SB 4)
##
mkValidator : TxOutputRef ‚Üí (State ‚Üí Value ‚Üí PendingTx ‚Üí (‚Ñï √ó ‚Ñï) ‚Üí ‚Ñï ‚Üí Bool)
mkValidator tin _ _ _ tin‚Ä≤ _ = (id tin ‚â° SB proj‚ÇÅ tin‚Ä≤) ‚àß (index tin ‚â° SB proj‚ÇÇ tin‚Ä≤)
##
BIT _ : ‚Ñï ‚Üí Value
BIT v = [ (BIT -validator ‚ôØ , v) ]
##
withScripts : TxOutputRef ‚Üí TxInput
withScripts tin = record  { outputRef  = tin
                          ; redeemer   = Œª _ ‚Üí id tin , index tin
                          ; validator  = mkValidator tin }
##
withPolicy : TxOutputRef ‚Üí TxInput
withPolicy tin = record  { outputRef = tin
                         ; redeemer  = Œª _ ‚Üí tt
                         ; validator = BIT -validator }
##
_ at _ : Value ‚Üí Index addresses ‚Üí TxOutput
v at addr = record { value = v ; address = addr ; dataScript  = Œª _ ‚Üí tt }
\end{code}\end{agda}
\end{frame}

\begin{frame}{Example: Definitions of Transactions}
\begin{agda}\begin{code}
c‚ÇÄ , t‚ÇÅ , t‚ÇÇ , t‚ÇÉ , t‚ÇÑ , t‚ÇÖ , t‚ÇÜ : Tx
c‚ÇÄ = record  { inputs   = []
             ; outputs  = BIT 0 at (BIT -validator ‚ôØ) ‚à∑ BIT 0 at (BIT -validator ‚ôØ) ‚à∑ []
             ; forge    = BIT 0
             ; fee      = BIT 0 }
t‚ÇÅ = record  { inputs   = [ withPolicy c‚ÇÄ‚ÇÄ ]
             ; outputs  = [ BIT 1000 at ONEB ]
             ; forge    = BIT 1000
             ; fee      = BIT 0 }
VDOTS
t‚ÇÜ = record  { inputs   = withScripts t‚ÇÖ‚ÇÄ ‚à∑ withScripts t‚ÇÖ‚ÇÅ ‚à∑ []
             ; outputs  = [ BIT 999 at THREEB ]
             ; forge    = BIT 0
             ; fee      = BIT 1 }
\end{code}\end{agda}
\end{frame}

\begin{frame}{Example: Rewrite Rules}
Our hash function is a postulate, so our decision procedures will get stuck...
\begin{agda}\begin{code}
PRAGMAL OPTIONS {---rewriting-} PRAGMAR
postulate
  eq‚ÇÅ‚ÇÄ   : (mkValidator t‚ÇÅ‚ÇÄ)  ‚ôØ  ‚â°  ONEB
  VDOTS
  eq‚ÇÜ‚ÇÄ   : (mkValidator t‚ÇÜ‚ÇÄ)  ‚ôØ  ‚â°  THREEB
##
PRAGMAL BUILTIN REWRITE _ ‚â° _ PRAGMAR
PRAGMAL REWRITE eq‚ÇÄ , eq‚ÇÅ‚ÇÄ , DOTS , eq‚ÇÜ‚ÇÄ PRAGMAR
\end{code}\end{agda}
\end{frame}

\begin{frame}{Example: Correct-by-construction Ledger}
\begin{agda}\begin{code}
ex-ledger : ValidLedger (t‚ÇÜ ‚à∑ t‚ÇÖ ‚à∑ t‚ÇÑ ‚à∑ t‚ÇÉ ‚à∑ t‚ÇÇ ‚à∑ t‚ÇÅ ‚à∑ c‚ÇÄ ‚à∑ [])
ex-ledger =
  ‚àô  c‚ÇÄ ‚à∂- record  { DOTS }
  ‚äï  t‚ÇÅ ‚à∂- record  { validTxRefs           = toWitness {Q = validTxRefs? t‚ÇÅ l‚ÇÄ} tt
                   ; validOutputIndices    = toWitness {Q = validOutputIndices? DOTS} tt
                   ; validOutputRefs       = toWitness {Q = validOutputRef? DOTS} tt
                   ; validDataScriptTypes  = toWitness {Q = validDataScriptTypes? DOTS} tt
                   ; preservesValues       = toWitness {Q = preservesValues? DOTS} tt
                   ; noDoubleSpending      = toWitness {Q = noDoubleSpending? DOTS} tt
                   ; allInputsValidate     = toWitness {Q = allInputsValidate? DOTS} tt
                   ; validateValidHashes   = toWitness {Q = validateValidHashes? DOTS} tt
                   ; forging               = toWitness {Q = forging? DOTS} tt }
  ‚äï  t‚ÇÇ ‚à∂- record { DOTS }
  VDOTS
  ‚äï  t‚ÇÜ ‚à∂- record { DOTS }
##
utxo : list (unspentOutputs ex-ledger) ‚â° [ t‚ÇÜ‚ÇÄ ]
utxo = refl
\end{code}\end{agda}
\end{frame}


\section{Meta-theory}

\subsection{Weakening Lemma}
\begin{frame}{Weakening via Injections}
\begin{agda}\begin{code}
module Weakening
  (ùî∏ : Set) (_‚ôØ ^^ SA : HashFunction ùî∏) (_ ‚âü SA _ : Decidable {A = ùî∏} _ ‚â° _)
  (ùîπ : Set) (_‚ôØ ^^ SB : HashFunction ùîπ) (_ ‚âü SB _ : Decidable {A = ùîπ} _ ‚â° _)
  (A‚Ü™B : ùî∏ , _‚ôØ ^^ SA ‚Ü™ ùîπ , _‚ôØ ^^ SB)
  where
##
  import       UTxO.Validity  ùî∏ _‚ôØ ^^ SA _ ‚âü SA _ as A
  open import  UTxO.Validity  ùîπ _‚ôØ ^^ SB _ ‚âü SB _ as B
\end{code}\end{agda}
\end{frame}

\begin{frame}{Weakening Lemma}
\begin{agda}\begin{code}
  weakening : ‚àÄ {tx : A.Tx} {l : A.Ledger}

    ‚Üí  A.IsValidTx tx l
       {-\inferLine{6cm}-}
    ‚Üí  B.IsValidTx (weakenTx tx) (weakenLedger l)
  weakening = DOTS
\end{code}\end{agda}
\end{frame}


\subsection{Combining Ledgers}

\begin{frame}{Inspiration from Separation Logic}
\begin{itemize}
\item one wants to reason in a modular manner,
  \begin{itemize}
  \item conversely, one can study a ledgers by studying its components, that is we can reason \textit{compositionally}
  \end{itemize}
\item In concurrency, |P ‚àó Q| holds for disjoint parts of the memory heap
\item In blockchain, |P ‚àó Q| holds for disjoint parts of the ledger
  \begin{itemize}
  \item But what does it mean for two ledgers to be disjoint?
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Disjoint Ledgers}
Two ledgers |l| and |l‚Ä≤| are disjoint, when
\begin{enumerate}
\item No common transactions: |Disjoint l l‚Ä≤ = ‚àÄ t ‚Üí ¬¨ (t ‚àà l √ó v ‚àà l‚Ä≤)|
\item Validation does not break:
\begin{agda}\begin{code}
PreserveValidations : (l : Ledger) (l‚Ä≥ : Ledger) ‚Üí Interleaving l _ l‚Ä≥ ‚Üí Set
PreserveValidations l l‚Ä≥ inter =
  ‚àÄ tx ‚Üí (p : tx ‚àà l) ‚Üí
    ‚àÄ {ptx i out vds}  ‚Üí  runValidation ptx i out vds (getState l‚Ä≥)
                       ‚â°  runValidation ptx i out vds (getState l)
\end{code}\end{agda}
\end{enumerate}
\end{frame}

\begin{frame}{Combining Ledgers}
\begin{agda}\begin{code}
_ ‚Üî _ ‚à∂- _ : ‚àÄ {l l‚Ä≤ l‚Ä≥ : Ledger}
  ‚Üí  ValidLedger l
  ‚Üí  ValidLedger l‚Ä≤
  ‚Üí  Œ£[ i ‚àà Interleaving l l‚Ä≤ l‚Ä≥ ]
  √ó  Disjoint l l‚Ä≤
  √ó  PreserveValidations l l‚Ä≥ i
  √ó  PreserveValidations l‚Ä≤ l‚Ä≥ (swap i)
     {-\inferLine{6cm}-}
  ‚Üí  ValidLedger l‚Ä≥
\end{code}\end{agda}
\end{frame}
